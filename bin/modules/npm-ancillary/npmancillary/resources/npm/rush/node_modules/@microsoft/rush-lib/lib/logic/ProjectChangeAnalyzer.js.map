{"version":3,"file":"ProjectChangeAnalyzer.js","sourceRoot":"","sources":["../../src/logic/ProjectChangeAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as crypto from 'crypto';\r\nimport ignore, { Ignore } from 'ignore';\r\n\r\nimport { getPackageDeps, getGitHashForFiles } from '@rushstack/package-deps-hash';\r\nimport { Path, InternalError, FileSystem, ITerminal } from '@rushstack/node-core-library';\r\n\r\nimport { RushConfiguration } from '../api/RushConfiguration';\r\nimport { RushProjectConfiguration } from '../api/RushProjectConfiguration';\r\nimport { Git } from './Git';\r\nimport { BaseProjectShrinkwrapFile } from './base/BaseProjectShrinkwrapFile';\r\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\r\nimport { RushConstants } from './RushConstants';\r\nimport { UNINITIALIZED } from '../utilities/Utilities';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport interface IGetChangedProjectsOptions {\r\n  targetBranchName: string;\r\n  terminal: ITerminal;\r\n  shouldFetch?: boolean;\r\n}\r\n\r\n/**\r\n * @beta\r\n */\r\nexport class ProjectChangeAnalyzer {\r\n  /**\r\n   * UNINITIALIZED === we haven't looked\r\n   * undefined === data isn't available (i.e. - git isn't present)\r\n   */\r\n  private _data: Map<string, Map<string, string>> | undefined | UNINITIALIZED = UNINITIALIZED;\r\n  private _filteredData: Map<string, Map<string, string>> = new Map<string, Map<string, string>>();\r\n  private _projectStateCache: Map<string, string> = new Map<string, string>();\r\n  private _rushConfiguration: RushConfiguration;\r\n  private readonly _git: Git;\r\n\r\n  public constructor(rushConfiguration: RushConfiguration) {\r\n    this._rushConfiguration = rushConfiguration;\r\n    this._git = new Git(this._rushConfiguration);\r\n  }\r\n\r\n  /**\r\n   * Try to get a list of the specified project's dependencies and their hashes.\r\n   *\r\n   * @remarks\r\n   * If the data can't be generated (i.e. - if Git is not present) this returns undefined.\r\n   *\r\n   * @internal\r\n   */\r\n  public async _tryGetProjectDependenciesAsync(\r\n    projectName: string,\r\n    terminal: ITerminal\r\n  ): Promise<Map<string, string> | undefined> {\r\n    // Check the cache for any existing data\r\n    const existingData: Map<string, string> | undefined = this._filteredData.get(projectName);\r\n    if (existingData) {\r\n      return existingData;\r\n    }\r\n\r\n    if (this._data === UNINITIALIZED) {\r\n      this._data = await this._getDataAsync(terminal);\r\n    }\r\n\r\n    if (this._data === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    const project: RushConfigurationProject | undefined =\r\n      this._rushConfiguration.getProjectByName(projectName);\r\n    if (!project) {\r\n      throw new Error(`Project \"${projectName}\" does not exist in the current Rush configuration.`);\r\n    }\r\n\r\n    const unfilteredProjectData: Map<string, string> = this._data.get(projectName)!;\r\n    let filteredProjectData: Map<string, string> | undefined;\r\n\r\n    const ignoreMatcher: Ignore | undefined = await this._getIgnoreMatcherForProjectAsync(project, terminal);\r\n    if (ignoreMatcher) {\r\n      // At this point, `filePath` is guaranteed to start with `projectRelativeFolder`, so\r\n      // we can safely slice off the first N characters to get the file path relative to the\r\n      // root of the project.\r\n      filteredProjectData = new Map<string, string>();\r\n      for (const [filePath, fileHash] of unfilteredProjectData) {\r\n        const relativePath: string = filePath.slice(project.projectRelativeFolder.length + 1);\r\n        if (!ignoreMatcher.ignores(relativePath)) {\r\n          // Add the file path to the filtered data if it is not ignored\r\n          filteredProjectData.set(filePath, fileHash);\r\n        }\r\n      }\r\n    } else {\r\n      filteredProjectData = unfilteredProjectData;\r\n    }\r\n\r\n    this._filteredData.set(projectName, filteredProjectData);\r\n    return filteredProjectData;\r\n  }\r\n\r\n  /**\r\n   * The project state hash is calculated in the following way:\r\n   * - Project dependencies are collected (see ProjectChangeAnalyzer.getPackageDeps)\r\n   *   - If project dependencies cannot be collected (i.e. - if Git isn't available),\r\n   *     this function returns `undefined`\r\n   * - The (path separator normalized) repo-root-relative dependencies' file paths are sorted\r\n   * - A SHA1 hash is created and each (sorted) file path is fed into the hash and then its\r\n   *   Git SHA is fed into the hash\r\n   * - A hex digest of the hash is returned\r\n   *\r\n   * @internal\r\n   */\r\n  public async _tryGetProjectStateHashAsync(\r\n    projectName: string,\r\n    terminal: ITerminal\r\n  ): Promise<string | undefined> {\r\n    let projectState: string | undefined = this._projectStateCache.get(projectName);\r\n    if (!projectState) {\r\n      const packageDeps: Map<string, string> | undefined = await this._tryGetProjectDependenciesAsync(\r\n        projectName,\r\n        terminal\r\n      );\r\n      if (!packageDeps) {\r\n        return undefined;\r\n      } else {\r\n        const sortedPackageDepsFiles: string[] = Array.from(packageDeps.keys()).sort();\r\n        const hash: crypto.Hash = crypto.createHash('sha1');\r\n        for (const packageDepsFile of sortedPackageDepsFiles) {\r\n          hash.update(packageDepsFile);\r\n          hash.update(RushConstants.hashDelimiter);\r\n          hash.update(packageDeps.get(packageDepsFile)!);\r\n          hash.update(RushConstants.hashDelimiter);\r\n        }\r\n\r\n        projectState = hash.digest('hex');\r\n        this._projectStateCache.set(projectName, projectState);\r\n      }\r\n    }\r\n\r\n    return projectState;\r\n  }\r\n\r\n  /**\r\n   * Gets a list of projects that have changed in the current state of the repo\r\n   * when compared to the specified branch.\r\n   */\r\n  public async *getChangedProjectsAsync(\r\n    options: IGetChangedProjectsOptions\r\n  ): AsyncIterable<RushConfigurationProject> {\r\n    const changedFolders: string[] | undefined = this._git.getChangedFolders(\r\n      options.targetBranchName,\r\n      options.terminal,\r\n      options.shouldFetch\r\n    );\r\n\r\n    if (changedFolders) {\r\n      const repoRootFolder: string | undefined = this._git.getRepositoryRootPath();\r\n      for (const project of this._rushConfiguration.projects) {\r\n        const projectFolder: string = repoRootFolder\r\n          ? path.relative(repoRootFolder, project.projectFolder)\r\n          : project.projectRelativeFolder;\r\n        if (this._hasProjectChanged(changedFolders, projectFolder)) {\r\n          yield project;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _hasProjectChanged(changedFolders: string[], projectFolder: string): boolean {\r\n    for (const folder of changedFolders) {\r\n      if (Path.isUnderOrEqual(folder, projectFolder)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private async _getDataAsync(terminal: ITerminal): Promise<Map<string, Map<string, string>> | undefined> {\r\n    const repoDeps: Map<string, string> | undefined = this._getRepoDeps(terminal);\r\n    if (!repoDeps) {\r\n      return undefined;\r\n    }\r\n\r\n    const projectHashDeps: Map<string, Map<string, string>> = new Map();\r\n\r\n    for (const project of this._rushConfiguration.projects) {\r\n      projectHashDeps.set(project.packageName, new Map());\r\n    }\r\n\r\n    // Sort each project folder into its own package deps hash\r\n    for (const [filePath, fileHash] of repoDeps) {\r\n      // findProjectForPosixRelativePath uses LookupByPath, for which lookups are O(K)\r\n      // K being the maximum folder depth of any project in rush.json (usually on the order of 3)\r\n      const owningProject: RushConfigurationProject | undefined =\r\n        this._rushConfiguration.findProjectForPosixRelativePath(filePath);\r\n\r\n      if (owningProject) {\r\n        const owningProjectHashDeps: Map<string, string> = projectHashDeps.get(owningProject.packageName)!;\r\n        owningProjectHashDeps.set(filePath, fileHash);\r\n      }\r\n    }\r\n\r\n    // Currently, only pnpm handles project shrinkwraps\r\n    if (this._rushConfiguration.packageManager === 'pnpm') {\r\n      const projects: RushConfigurationProject[] = [];\r\n      const projectDependencyManifestPaths: string[] = [];\r\n\r\n      for (const project of this._rushConfiguration.projects) {\r\n        const projectShrinkwrapFilePath: string = BaseProjectShrinkwrapFile.getFilePathForProject(project);\r\n        const relativeProjectShrinkwrapFilePath: string = Path.convertToSlashes(\r\n          path.relative(this._rushConfiguration.rushJsonFolder, projectShrinkwrapFilePath)\r\n        );\r\n\r\n        if (!FileSystem.exists(projectShrinkwrapFilePath)) {\r\n          throw new Error(\r\n            `A project dependency file (${relativeProjectShrinkwrapFilePath}) is missing. You may need to run ` +\r\n              '\"rush install\" or \"rush update\".'\r\n          );\r\n        }\r\n\r\n        projects.push(project);\r\n        projectDependencyManifestPaths.push(relativeProjectShrinkwrapFilePath);\r\n      }\r\n\r\n      const gitPath: string = this._git.getGitPathOrThrow();\r\n      const hashes: Map<string, string> = getGitHashForFiles(\r\n        projectDependencyManifestPaths,\r\n        this._rushConfiguration.rushJsonFolder,\r\n        gitPath\r\n      );\r\n      for (let i: number = 0; i < projects.length; i++) {\r\n        const project: RushConfigurationProject = projects[i];\r\n        const projectDependencyManifestPath: string = projectDependencyManifestPaths[i];\r\n        if (!hashes.has(projectDependencyManifestPath)) {\r\n          throw new InternalError(`Expected to get a hash for ${projectDependencyManifestPath}`);\r\n        }\r\n\r\n        const hash: string = hashes.get(projectDependencyManifestPath)!;\r\n        projectHashDeps.get(project.packageName)!.set(projectDependencyManifestPath, hash);\r\n      }\r\n    } else {\r\n      // Determine the current variant from the link JSON.\r\n      const variant: string | undefined = this._rushConfiguration.currentInstalledVariant;\r\n\r\n      // Add the shrinkwrap file to every project's dependencies\r\n      const shrinkwrapFile: string = Path.convertToSlashes(\r\n        path.relative(\r\n          this._rushConfiguration.rushJsonFolder,\r\n          this._rushConfiguration.getCommittedShrinkwrapFilename(variant)\r\n        )\r\n      );\r\n\r\n      for (const project of this._rushConfiguration.projects) {\r\n        const shrinkwrapHash: string | undefined = repoDeps!.get(shrinkwrapFile);\r\n        if (shrinkwrapHash) {\r\n          projectHashDeps.get(project.packageName)!.set(shrinkwrapFile, shrinkwrapHash);\r\n        }\r\n      }\r\n    }\r\n\r\n    return projectHashDeps;\r\n  }\r\n\r\n  private async _getIgnoreMatcherForProjectAsync(\r\n    project: RushConfigurationProject,\r\n    terminal: ITerminal\r\n  ): Promise<Ignore | undefined> {\r\n    const projectConfiguration: RushProjectConfiguration | undefined =\r\n      await RushProjectConfiguration.tryLoadForProjectAsync(project, undefined, terminal);\r\n\r\n    if (projectConfiguration && projectConfiguration.incrementalBuildIgnoredGlobs) {\r\n      const ignoreMatcher: Ignore = ignore();\r\n      ignoreMatcher.add(projectConfiguration.incrementalBuildIgnoredGlobs);\r\n      return ignoreMatcher;\r\n    }\r\n  }\r\n\r\n  private _getRepoDeps(terminal: ITerminal): Map<string, string> | undefined {\r\n    try {\r\n      if (this._git.isPathUnderGitWorkingTree()) {\r\n        // Load the package deps hash for the whole repository\r\n        const gitPath: string = this._git.getGitPathOrThrow();\r\n        return getPackageDeps(this._rushConfiguration.rushJsonFolder, [], gitPath);\r\n      } else {\r\n        return undefined;\r\n      }\r\n    } catch (e) {\r\n      // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about\r\n      // the state of the files in the repo. This can happen if the environment doesn't have Git.\r\n      terminal.writeWarningLine(\r\n        `Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`\r\n      );\r\n\r\n      return undefined;\r\n    }\r\n  }\r\n}\r\n"]}