{"version":3,"file":"ProjectWatcher.js","sourceRoot":"","sources":["../../src/logic/ProjectWatcher.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as fs from 'fs';\r\nimport * as os from 'os';\r\nimport { once } from 'events';\r\nimport { Path, ITerminal } from '@rushstack/node-core-library';\r\n\r\nimport { ProjectChangeAnalyzer } from './ProjectChangeAnalyzer';\r\nimport { RushConfiguration } from '../api/RushConfiguration';\r\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\r\n\r\nexport interface IProjectWatcherOptions {\r\n  debounceMilliseconds?: number;\r\n  rushConfiguration: RushConfiguration;\r\n  projectsToWatch: ReadonlySet<RushConfigurationProject>;\r\n  terminal: ITerminal;\r\n}\r\n\r\nexport interface IProjectChangeResult {\r\n  /**\r\n   * The set of projects that have changed since the last iteration\r\n   */\r\n  changedProjects: ReadonlySet<RushConfigurationProject>;\r\n  /**\r\n   * Contains the git hashes for all tracked files in the repo\r\n   */\r\n  state: ProjectChangeAnalyzer;\r\n}\r\n\r\n/**\r\n * This class is for incrementally watching a set of projects in the repository for changes.\r\n *\r\n * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean\r\n * signal indicating that \"at least 1 file in a watched project changed\". We then defer to ProjectChangeAnalyzer (which\r\n * is responsible for change detection in all incremental builds) to determine what actually chanaged.\r\n *\r\n * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or\r\n * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.\r\n */\r\nexport class ProjectWatcher {\r\n  private readonly _debounceMilliseconds: number;\r\n  private readonly _rushConfiguration: RushConfiguration;\r\n  private readonly _projectsToWatch: ReadonlySet<RushConfigurationProject>;\r\n  private readonly _terminal: ITerminal;\r\n\r\n  private _initialState: ProjectChangeAnalyzer | undefined;\r\n  private _previousState: ProjectChangeAnalyzer | undefined;\r\n\r\n  public constructor(options: IProjectWatcherOptions) {\r\n    const { debounceMilliseconds = 1000, rushConfiguration, projectsToWatch, terminal } = options;\r\n\r\n    this._debounceMilliseconds = debounceMilliseconds;\r\n    this._rushConfiguration = rushConfiguration;\r\n    this._projectsToWatch = projectsToWatch;\r\n    this._terminal = terminal;\r\n  }\r\n\r\n  /**\r\n   * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.\r\n   * Will return immediately the first time it is invoked, since no state has been recorded.\r\n   * If no change is currently present, watches the source tree of all selected projects for file changes.\r\n   */\r\n  public async waitForChange(onWatchingFiles?: () => void): Promise<IProjectChangeResult> {\r\n    const initialChangeResult: IProjectChangeResult = await this._computeChanged();\r\n    // Ensure that the new state is recorded so that we don't loop infinitely\r\n    this._commitChanges(initialChangeResult.state);\r\n    if (initialChangeResult.changedProjects.size) {\r\n      return initialChangeResult;\r\n    }\r\n\r\n    const previousState: ProjectChangeAnalyzer = initialChangeResult.state;\r\n    const repoRoot: string = Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);\r\n\r\n    const pathsToWatch: Set<string> = new Set();\r\n\r\n    // Node 12 supports the \"recursive\" parameter to fs.watch only on win32 and OSX\r\n    // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats\r\n    const useNativeRecursiveWatch: boolean = os.platform() === 'win32' || os.platform() === 'darwin';\r\n\r\n    for (const project of this._projectsToWatch) {\r\n      const projectState: Map<string, string> = (await previousState._tryGetProjectDependenciesAsync(\r\n        project.packageName,\r\n        this._terminal\r\n      ))!;\r\n      const projectFolder: string = project.projectRelativeFolder;\r\n      // Watch files in the root of the project, or\r\n      for (const fileName of projectState.keys()) {\r\n        for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(\r\n          fileName,\r\n          projectFolder,\r\n          useNativeRecursiveWatch\r\n        )) {\r\n          pathsToWatch.add(`${repoRoot}/${pathToWatch}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    const watchers: Map<string, fs.FSWatcher> = new Map();\r\n\r\n    const watchedResult: IProjectChangeResult = await new Promise(\r\n      (resolve: (result: IProjectChangeResult) => void, reject: (err: Error) => void) => {\r\n        let timeout: NodeJS.Timeout | undefined;\r\n        let terminated: boolean = false;\r\n\r\n        const resolveIfChanged = async (): Promise<void> => {\r\n          timeout = undefined;\r\n          if (terminated) {\r\n            return;\r\n          }\r\n\r\n          try {\r\n            const result: IProjectChangeResult = await this._computeChanged();\r\n\r\n            // Need an async tick to allow for more file system events to be handled\r\n            process.nextTick(() => {\r\n              if (timeout) {\r\n                // If another file has changed, wait for another pass.\r\n                return;\r\n              }\r\n\r\n              this._commitChanges(result.state);\r\n\r\n              if (result.changedProjects.size) {\r\n                terminated = true;\r\n                resolve(result);\r\n              }\r\n            });\r\n          } catch (err) {\r\n            // eslint-disable-next-line require-atomic-updates\r\n            terminated = true;\r\n            reject(err as NodeJS.ErrnoException);\r\n          }\r\n        };\r\n\r\n        const onError = (err: Error): void => {\r\n          if (terminated) {\r\n            return;\r\n          }\r\n\r\n          terminated = true;\r\n          reject(err);\r\n        };\r\n\r\n        const addWatcher = (\r\n          watchedPath: string,\r\n          listener: (event: string, fileName: string | Buffer) => void\r\n        ): void => {\r\n          const watcher: fs.FSWatcher = fs.watch(\r\n            watchedPath,\r\n            {\r\n              encoding: 'utf-8',\r\n              recursive: useNativeRecursiveWatch\r\n            },\r\n            listener\r\n          );\r\n          watchers.set(watchedPath, watcher);\r\n          watcher.on('error', (err) => {\r\n            watchers.delete(watchedPath);\r\n            onError(err);\r\n          });\r\n        };\r\n\r\n        const changeListener = (event: string, fileName: string | Buffer): void => {\r\n          try {\r\n            if (terminated) {\r\n              return;\r\n            }\r\n\r\n            // Handling for added directories\r\n            if (!useNativeRecursiveWatch) {\r\n              const decodedName: string = fileName && fileName.toString();\r\n              const normalizedName: string = decodedName && Path.convertToSlashes(decodedName);\r\n\r\n              if (normalizedName && !watchers.has(normalizedName)) {\r\n                try {\r\n                  const stat: fs.Stats = fs.statSync(fileName);\r\n                  if (stat.isDirectory()) {\r\n                    addWatcher(normalizedName, changeListener);\r\n                  }\r\n                } catch (err) {\r\n                  const code: string | undefined = (err as NodeJS.ErrnoException).code;\r\n\r\n                  if (code !== 'ENOENT' && code !== 'ENOTDIR') {\r\n                    throw err;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.\r\n            if (timeout) {\r\n              clearTimeout(timeout);\r\n            }\r\n\r\n            timeout = setTimeout(resolveIfChanged, this._debounceMilliseconds);\r\n          } catch (err) {\r\n            terminated = true;\r\n            reject(err as NodeJS.ErrnoException);\r\n          }\r\n        };\r\n\r\n        for (const pathToWatch of pathsToWatch) {\r\n          addWatcher(pathToWatch, changeListener);\r\n        }\r\n\r\n        if (onWatchingFiles) {\r\n          onWatchingFiles();\r\n        }\r\n      }\r\n    );\r\n\r\n    const closePromises: Promise<void>[] = [];\r\n    for (const [watchedPath, watcher] of watchers) {\r\n      closePromises.push(\r\n        once(watcher, 'close').then(() => {\r\n          watchers.delete(watchedPath);\r\n        })\r\n      );\r\n      watcher.close();\r\n    }\r\n\r\n    await Promise.all(closePromises);\r\n\r\n    return watchedResult;\r\n  }\r\n\r\n  /**\r\n   * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore\r\n   */\r\n  private async _computeChanged(): Promise<IProjectChangeResult> {\r\n    const state: ProjectChangeAnalyzer = new ProjectChangeAnalyzer(this._rushConfiguration);\r\n\r\n    const previousState: ProjectChangeAnalyzer | undefined = this._previousState;\r\n\r\n    if (!previousState) {\r\n      return {\r\n        changedProjects: this._projectsToWatch,\r\n        state\r\n      };\r\n    }\r\n\r\n    const changedProjects: Set<RushConfigurationProject> = new Set();\r\n    for (const project of this._projectsToWatch) {\r\n      const { packageName } = project;\r\n\r\n      if (\r\n        ProjectWatcher._haveProjectDepsChanged(\r\n          (await previousState._tryGetProjectDependenciesAsync(packageName, this._terminal))!,\r\n          (await state._tryGetProjectDependenciesAsync(packageName, this._terminal))!\r\n        )\r\n      ) {\r\n        // May need to detect if the nature of the change will break the process, e.g. changes to package.json\r\n        changedProjects.add(project);\r\n      }\r\n    }\r\n\r\n    return {\r\n      changedProjects,\r\n      state\r\n    };\r\n  }\r\n\r\n  private _commitChanges(state: ProjectChangeAnalyzer): void {\r\n    this._previousState = state;\r\n    if (!this._initialState) {\r\n      this._initialState = state;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tests for inequality of the passed Maps. Order invariant.\r\n   *\r\n   * @returns `true` if the maps are different, `false` otherwise\r\n   */\r\n  private static _haveProjectDepsChanged(prev: Map<string, string>, next: Map<string, string>): boolean {\r\n    if (prev.size !== next.size) {\r\n      return true;\r\n    }\r\n\r\n    for (const [key, value] of prev) {\r\n      if (next.get(key) !== value) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private static *_enumeratePathsToWatch(\r\n    path: string,\r\n    projectRelativeFolder: string,\r\n    useNativeRecursiveWatch: boolean\r\n  ): Iterable<string> {\r\n    const rootSlashIndex: number = path.indexOf('/', projectRelativeFolder.length + 2);\r\n\r\n    if (rootSlashIndex < 0) {\r\n      yield path;\r\n      return;\r\n    }\r\n\r\n    yield path.slice(0, rootSlashIndex);\r\n\r\n    if (useNativeRecursiveWatch) {\r\n      // Only need the root folder if fs.watch can be called with recursive: true\r\n      return;\r\n    }\r\n\r\n    let slashIndex: number = path.lastIndexOf('/');\r\n    while (slashIndex > rootSlashIndex) {\r\n      yield path.slice(0, slashIndex);\r\n      slashIndex = path.lastIndexOf('/', slashIndex - 1);\r\n    }\r\n  }\r\n}\r\n"]}